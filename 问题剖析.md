# 问题剖析

## 1.为何char类型的范围为 -128 -127

对于无符号数而言，将全部位表示数值。用二进制表示就是 0000  0000 ~ 1111 1111 ，所以其范围为 0~255 ，能表示状态为256个。

对于有符号数而言，最高位为符号位， 0 表示正数， -1 表示负数。 这样一来，只有7位来表示数值。

 0 111 1111 = 127
 1 111 1111 = -127   ，所以取值范围应该为 -127 ~127 。 但是其中间有两个0表示。   

```c
1000 0000   = -0  

0000 0000   = 0  
```

这显然是没有必要的，仅需要一个0就足够了嘛。 所以需要给 1000 0000 安排个正确的数值。于是教科书上却写着 -128 ~127。 

-127 — 0 —— 127 都有相应的原码与其对应 ， 那么 1 000 0000 表示什么呢？ 答案就是 -128.

首先来看一下 -128 在计算机中是如何表示的， -128 的原码为 1 1000 0000， 反码 ： 1 0111 1111 ，补码： 1 1000 0000   

由于char 是8位 ， 需要把-128的最高符号位1 给丢弃， 截断后 -128的原码 1000 0000 与-0 的原码相同，所以就把 -0 用 -128 来表示。

 最终char类型的取值范围就变成了 -128 ~127.

## 2. 在c++中， 如何让某个类只能通过new来创建（即如果直接创建对象，编译器会报错）

类的对象建立分为==静态建立==  ```A a``` 和==动态建立== ```A* p = new A```

静态建立： 编译器在栈空间中分配内存。通过直接移动堆栈指针，挪出适当的空间，然后在该内存空间上**直接调用构造函数**形成一个栈对象。

动态建立：利用new 操作符将对象创建在堆空间中。过程分为两步， 第一步是执行 operator new()函数，在堆空间中搜索合适的内存并进行分配； 第二步是调用构造函数初始化这片空间。 该方法属于**间接**调用类的构造函数。

1. 只能在堆上分配类对象，就是不能静态建立类对象，即不能直接调用类的构造函数

   当对象建立在栈上面时，编译器管理了对象的整个生命周期。

   编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，**将析构函数设为私有，类对象就无法建立在栈上了**

   ```c++
   clas A
   {
   	public:
   	 	A(){}
   	 	void destory(){delete this;}
   	private:
       	~A(){}
   };
   //试着使用A a;来建立对象，编译报错，提示析构函数无法访问。
   //只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。
   
   ```

   上述方法的缺点：

   1. **无法解决继承问题，**如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问

   2. **类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。**（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）

      为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。代码如下，类似于***\*单例模式\****：

```c++
//调用create()函数在堆上创建类A对象，调用destory()函数释放内存。
class A  
{  
protected:  
    A(){}  
    ~A(){}  
public:  
    static A* create()  
    {  
        return new A();  
    }  
    void destory()  
    {  
        delete this;  
    }  
};
```

2. **只能在栈上分配**类对象

​	只要禁用new运算符就可以实现类对象只能建立在栈上，new operator 总是先调用 operator new,而后者我们是可以自行声明重写的，因此将operator new 设为私有，代码如下

```c++
class A  
{  
private:  
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的  
    void operator delete(void* ptr){} // 重载了new就需要重载delete  
public:  
    A(){}  
    ~A(){}  
};
```

3. momcpy和memmove的区别

   memcpy按字节进行直接复制， 没有对源数据和目标数据之间的重叠进行检查

   memmove首先会检测源数据和目标数据之间是否存在重叠， 如果无，则跟memcpy类似。如果有则继续特殊处理：

   - src在dest的前面，则从源起始开始逐个字节向目标的末尾复制
   - dest在src的前面， 则从源末尾开始逐个字节向目标的起始复制。

4. shared_Ptr是线程安全的么？

   通过引用计数来管理对象的所有权，引用计数是一个原子操作（所谓原子操作，就是**不可中断**，它要么完全执行，要么完全不执行）， 因此多个线程可以安全地同时增加或减少引用计数。

   虽然shared_ptr本身是线程安全的，这意味着你可以在多个线程之间对 `std::shared_ptr` 进行操作，比如拷贝构造、析构等，而不需要额外的同步手段。但与其相关的共享资源（被智能指针管理的对象）可能不是线程安全的，具体而言， 如果多个线程同时通过智能指针访问和修改共享资源， 需要利用其它手段来确保对共享资源的安全访问。这是因为 `std::shared_ptr` 管理的是对象的生命周期，而不控制对象本身的线程安全性。

   ```c++
   #include <memory>
   #include <iostream>
   #include <thread>
   //在这个例子中，SharedResource 类中的 modifyResource 函数模拟对共享资源的修改。虽然 std::shared_ptr 本身是线程安全的，但是由于两个线程同时访问了共享的 sharedResource 对象，这可能导致竞态条件，从而使得输出结果不一致。
   class SharedResource {
   public:
       void modifyResource() {
           // 模拟对共享资源的修改
           std::cout << "Modifying resource...\n";
       }
   };
   
   int main() {
       std::shared_ptr<SharedResource> sharedResource = std::make_shared<SharedResource>();
   
       // 多个线程通过相同的 shared_ptr 访问共享资源
       std::thread t1([sharedResource]() {
           // 在线程1中访问共享资源
           sharedResource->modifyResource();
       });
   
       std::thread t2([sharedResource]() {
           // 在线程2中访问共享资源
           sharedResource->modifyResource();
       });
   
       t1.join();
       t2.join();
   
       return 0;
   }
   
   ```

   

 5. 在栈上动态分配内存	

    `alloca` 函数是一个非标准的 C 和 C++ 函数，用于在栈上动态分配内存。它类似于 `malloc` 函数。与 `malloc` 不同，`alloca` 不需要显式调用 `free` 来释放内存，因为分配的内存会在函数返回时自动被释放，这是因为它是分配在栈上的。

    需要注意的是，由于 `alloca` 不是标准函数，它的使用可能不具有可移植性，并且在一些编译器中可能没有定义

6. 拷贝构造和赋值运算符重载的区别

   拷贝构造函数： 在创建一个新对象并用同一类的另一个对象进行初始化时调用。无需显式调用，由编译器在特定情况下自动生成调用。

   赋值运算符重载： 在已经存在的对象上进行赋值操作时调用。 使用运算符 “=”进行调用。

```c++
#include <iostream>

class MyClass {
public:
    // 拷贝构造函数
    MyClass(const MyClass& other) {
        std::cout << "Copy constructor called\n";
        // 进行适当的复制操作
    }

    // 赋值运算符重载
    MyClass& operator=(const MyClass& other) {
        std::cout << "Copy assignment operator called\n";
        if (this != &other) {
            // 进行适当的赋值操作
        }
        return *this;
    }
};

int main() {
    MyClass obj1;           // 调用默认构造函数
    MyClass obj2 = obj1;    // 调用拷贝构造函数
    MyClass obj3;
    obj3 = obj1;            // 调用赋值运算符重载

    return 0;
}

```

